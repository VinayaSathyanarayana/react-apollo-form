{"version":3,"file":"static/preview.c98f0a76fdc424415642.bundle.js","sources":["webpack:///./lib/forms/utils.ts"],"sourcesContent":["// tslint:disable:no-any\nimport { PureQueryOptions } from 'apollo-client';\nimport { every } from 'async';\nimport { DocumentNode } from 'graphql';\nimport { JSONSchema6 } from 'json-schema';\nimport {\n    cloneDeep, filter, get,\n    has, isPlainObject, isUndefined,\n    last,\n    map,\n    merge,\n    set,\n    take,\n    transform,\n    uniq,\n    unset,\n    Dictionary,\n    MemoVoidDictionaryIterator\n} from 'lodash';\nimport { RefetchQueriesProviderFn } from 'react-apollo';\nimport { UiSchema } from 'react-jsonschema-form';\nimport { retrieveSchema } from 'react-jsonschema-form/lib/utils';\nimport { isObject } from 'util';\nimport { ApolloFormUi } from './component';\nimport { ApolloFormBuilder } from './definitions';\n\n// ApolloForm options object is composed of 2 modes : \"mutation\" or \"manual\"\nexport type ApolloFormConfigBase = {\n    name?: string;\n    // ability to ignore specific fields, eg: [\"user.id\"]\n    ignoreFields?: string[];\n    // ability to set specific fields to required, eg: [\"user.email\"]\n    requiredFields?: string[];\n    // update a existing field config (merge, not override)\n    updateFields?: { [k: string]: object };\n    // update directly schema (merge, not override)\n    augment?: object;\n};\n\nexport interface ApolloFormConfigMutation extends ApolloFormConfigBase {\n    mutation: {\n        name: string;\n        document: DocumentNode;\n        variables?: object;\n        context?: object;\n        refetchQueries?: string[] | PureQueryOptions[] | RefetchQueriesProviderFn;\n    };\n}\n\nexport interface ApolloFormConfigManual extends ApolloFormConfigBase {\n    schema: JSONSchema6;\n    saveData: (formData: any) => any;\n}\n\nexport type ApolloFormConfig = ApolloFormConfigManual | ApolloFormConfigMutation;\n\n// type guard\nexport const isMutationConfig = (config: ApolloFormConfig): config is ApolloFormConfigMutation => {\n    return !!get(config, 'mutation') && get(config, 'mutation.name');\n};\n\n// Given a schema, expand properties that reference a definition\nexport const flattenSchemaProperties = (schema: any): any => {\n    return transform(\n        schema.properties,\n        (result, value, key) => {\n            if (get(value, '$ref')) {\n                result[key] = retrieveSchema(value, schema.definitions);\n            } else {\n                result[key] = value;\n            }\n            return result;\n        },\n        {}\n    );\n};\n\nconst applyConditionsReducer =\n    (ui: UiSchema & ApolloFormUi, data: object) =>\n        (acc: JSONSchema6, curr: JSONSchema6, key: string) => {\n            const propUi: (UiSchema & ApolloFormUi) | undefined = get(ui, key);\n            const prop = last(key.split('.'));\n            if (propUi && propUi['ui:if']) {\n                if (\n                    filter(propUi['ui:if'], (predicate, k) => {\n                        const value = get(data, k);\n                        return predicate && predicate !== value;\n                    }).length === 0\n                ) {\n                    Object.assign(acc, curr);\n                }\n            } else if (has(curr, 'properties')) {\n                Object.assign(\n                    acc,\n                    {\n                        [prop]: {\n                            type: 'object',\n                            properties: {},\n                            ...(curr.required ? { required: curr.required } : {})\n                        }\n                    }\n                );\n                map(curr.properties, (v, k) => {\n                    (acc as any)[prop].properties[k] =\n                        applyConditionsReducer(ui, data)({}, v as JSONSchema6, `${key}.${k}`);\n                });\n            } else {\n                Object.assign(acc, curr);\n            }\n            return acc;\n        };\n\nexport const applyConditionsToSchema =\n    (jsonSchema: JSONSchema6, ui: UiSchema & ApolloFormUi, data: object): JSONSchema6 => {\n        const schema = cloneDeep(jsonSchema);\n        return schema.properties ?\n            Object.assign(\n                {},\n                schema,\n                {\n                    properties: transform(\n                        schema.properties,\n                        applyConditionsReducer(ui, data),\n                        {}\n                    )\n                }\n            ) :\n            schema;\n    };\n\n// Given a config, return a valid JSON Schema\nexport const getSchemaFromConfig = (jsonSchema: JSONSchema6, config: ApolloFormConfig, title?: string): JSONSchema6 => {\n    let schema: any;\n    // generated schema given mode: \"manual\" or \"mutation\"\n    if (!isMutationConfig(config)) {\n        schema = ApolloFormBuilder.getSchema(\n            jsonSchema,\n            config.schema.properties || {}\n        );\n    } else {\n        const mutationConfig = ApolloFormBuilder.getMutationConfig(jsonSchema, config.mutation.name);\n        schema = ApolloFormBuilder.getSchema(\n            jsonSchema,\n            mutationConfig.properties as any,\n            mutationConfig.required\n        );\n    }\n\n    let flattenSchema = cloneDeep(Object.assign({}, schema, { properties: flattenSchemaProperties(schema) }));\n\n    // schema modifiers\n    if (config.ignoreFields) {\n        config.ignoreFields.map(f => {\n            unset(flattenSchema.properties, f.replace(/\\./g, '.properties.'));\n        });\n    }\n\n    if (config.updateFields) {\n        map(config.updateFields, (fieldDef, fieldName) => {\n            const name = fieldName.replace(/\\./g, '.properties.');\n            set(\n                flattenSchema.properties,\n                name,\n                merge(get(flattenSchema.properties, name), fieldDef)\n            );\n        });\n    }\n\n    if (config.requiredFields) {\n        map(config.requiredFields, fieldName => {\n            const parts = fieldName.split('.');\n            const prop = last(parts);\n            const parentsPaths = take(parts, parts.length - 1);\n            const name = parentsPaths.join('.').replace(/\\./g, '.properties.');\n            const newRequired = uniq([...get(flattenSchema.properties, `${name}.required`), prop]);\n            set(\n                flattenSchema.properties,\n                `${name}.required`,\n                newRequired\n            );\n        });\n    }\n\n    if (config.augment) {\n        flattenSchema = merge({}, flattenSchema, config.augment);\n    }\n\n    return flattenSchema;\n};\n\n// Custom errors messages implementations\nexport type ReactJsonschemaFormError = {\n    message: string;\n    name: string;\n    params: object;\n    property: string;\n    stack: string;\n};\nexport const transformErrors = (prefix: string) => (errors: ReactJsonschemaFormError[]) => {\n    return errors.map(error => ({\n        ...error,\n        message: `FormError.${prefix}${error.property}.${error.name}`\n        // message: t(`FormError.${prefix}${error.property}.${error.name}`)\n    }));\n};\n\n// Given formData and form properties, remove all formData properties not present in form properties\nexport const cleanData = (formData: object, properties: object, parentPath: string | null = null): object => {\n    return transform(\n        formData as {},\n        (acc, curr, key) => {\n            const currentPath = parentPath ? `${parentPath}.${key}` : key;\n            if (has(properties, currentPath.replace(/\\./g, '.properties.'))) {\n                if (isPlainObject(curr)) {\n                    acc[key] = cleanData(curr, properties, currentPath);\n                } else {\n                    acc[key] = curr;\n                }\n            }\n            return acc;\n        },\n        {}\n    );\n};\n\n// awesome util for all components\n//      - Get prop boolean value even if undefined\nexport const isTruthyWithDefault = (value: undefined | boolean, defaultValue = true) => {\n    return isUndefined(value) ? defaultValue : !!value;\n};\n"],"mappings":"AAKA","sourceRoot":""}